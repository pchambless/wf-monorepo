/**
 * Document Registration Service
 * Part of Plan 0018 Phase 3: Document Management Integration
 *
 * Handles registration of documents in the plan_documents database table
 * via the DML API system.
 */

import { api } from "../api/index.js";

/**
 * Register a new document in the plan_documents table
 * @param {Object} metadata - Document metadata from parseDocumentMetadata
 * @returns {Promise<Object>} - Success/error response
 */
export async function registerDocument(metadata) {
  try {
    const dmlPayload = {
      method: "INSERT",
      table: "api_wf.plan_documents",
      data: {
        plan_id: metadata.plan_id,
        document_type: metadata.document_type,
        file_path: metadata.file_path,
        title: metadata.title,
        author: metadata.author || "kiro",
        status: metadata.status || "draft",
        userID: 1, // Use numeric userID for now - audit trail details can be refined later
        // created_at, updated_at, created_by will be auto-generated by DML processor
      },
    };

    const response = await api.execDml("INSERT", dmlPayload);

    if (response.success) {
      return {
        success: true,
        documentId: response.insertId,
        message: `Document registered: ${metadata.title}`,
        metadata: metadata,
      };
    } else {
      return {
        success: false,
        error: response.error || "DML operation failed",
        metadata: metadata,
      };
    }
  } catch (error) {
    return {
      success: false,
      error: error.message || "Registration failed",
      metadata: metadata,
    };
  }
}

/**
 * Check if a document is already registered by file path
 * @param {string} filePath - Relative file path to check
 * @returns {Promise<Object>} - Existing document info or null
 */
export async function checkDocumentExists(filePath, planId) {
  try {
    // Get registered documents for the plan and filter for the specific file path
    const allDocsResult = await getRegisteredDocuments(planId);

    if (!allDocsResult.success) {
      console.warn(
        `Failed to check document existence for ${filePath}:`,
        allDocsResult.error
      );
      return {
        exists: false,
        document: null,
        checkFailed: true,
      };
    }

    const existingDoc = allDocsResult.documents.find(
      (doc) => doc.file_path === filePath
    );

    if (existingDoc) {
      return {
        exists: true,
        document: existingDoc,
      };
    } else {
      return {
        exists: false,
        document: null,
      };
    }
  } catch (error) {
    // If check fails, assume document doesn't exist to avoid blocking registration
    console.warn(
      `Failed to check document existence for ${filePath}:`,
      error.message
    );
    return {
      exists: false,
      document: null,
      checkFailed: true,
    };
  }
}

/**
 * Get registered documents for a specific plan
 * @param {number} planId - Plan ID to get documents for
 * @returns {Promise<Array>} - Array of registered document file paths
 */
export async function getRegisteredDocuments(planId) {
  try {
    // Follow Parameter Flow Contract: set parameter first, then call execEvent
    const { default: contextStore } = await import("../stores/contextStore.js");
    contextStore.setParameter("planID", planId);

    const docsResponse = await api.execEvent("planDocumentList");

    // The API returns the data directly as an array, not wrapped in success/data structure
    if (Array.isArray(docsResponse)) {
      return {
        success: true,
        documents: docsResponse,
      };
    } else {
      return {
        success: false,
        error: "Invalid response format",
        documents: [],
      };
    }
  } catch (error) {
    return {
      success: false,
      error: error.message || "Failed to fetch registered documents",
      documents: [],
    };
  }
}

/**
 * Update document status (for future workflow enhancements)
 * @param {number} documentId - Document ID
 * @param {string} status - New status ('draft', 'approved', 'obsolete')
 * @returns {Promise<Object>} - Success/error response
 */
export async function updateDocumentStatus(documentId, status) {
  try {
    const dmlPayload = {
      method: "UPDATE",
      table: "api_wf.plan_documents",
      data: {
        status: status,
        updated_by: "kiro",
        userID: 1, // Required for audit trail
        id: documentId, // Include the ID in data for WHERE clause
      },
    };

    const response = await api.execDml("UPDATE", dmlPayload);

    if (response.success) {
      return {
        success: true,
        message: `Document status updated to: ${status}`,
      };
    } else {
      return {
        success: false,
        error: response.error || "Status update failed",
      };
    }
  } catch (error) {
    return {
      success: false,
      error: error.message || "Status update failed",
    };
  }
}

/**
 * Link document to a plan (for manual association)
 * @param {number} documentId - Document ID
 * @param {number} planId - Plan ID to associate with
 * @returns {Promise<Object>} - Success/error response
 */
export async function linkDocumentToPlan(documentId, planId) {
  try {
    const dmlPayload = {
      method: "UPDATE",
      table: "api_wf.plan_documents",
      data: {
        plan_id: planId,
        updated_by: "kiro",
        userID: 1, // Required for audit trail
        id: documentId, // Include the ID in data for WHERE clause
      },
    };

    const response = await api.execDml("UPDATE", dmlPayload);

    if (response.success) {
      return {
        success: true,
        message: `Document linked to plan ${planId}`,
      };
    } else {
      return {
        success: false,
        error: response.error || "Plan linking failed",
      };
    }
  } catch (error) {
    return {
      success: false,
      error: error.message || "Plan linking failed",
    };
  }
}

/**
 * Batch register multiple documents
 * @param {Array} metadataArray - Array of document metadata objects
 * @param {number} planId - Plan ID for checking existing documents
 * @returns {Promise<Object>} - Batch registration results
 */
export async function batchRegisterDocuments(metadataArray, planId) {
  const results = {
    success: [],
    failed: [],
    skipped: [],
  };

  for (const metadata of metadataArray) {
    try {
      // Check if document already exists
      const existsCheck = await checkDocumentExists(metadata.file_path, planId);

      if (existsCheck.exists) {
        results.skipped.push({
          metadata: metadata,
          reason: "Already registered",
          existing: existsCheck.document,
        });
        continue;
      }

      // Register the document
      const registerResult = await registerDocument(metadata);

      if (registerResult.success) {
        results.success.push(registerResult);
      } else {
        results.failed.push(registerResult);
      }
    } catch (error) {
      results.failed.push({
        success: false,
        error: error.message,
        metadata: metadata,
      });
    }
  }

  return {
    summary: {
      registered: results.success.length,
      failed: results.failed.length,
      skipped: results.skipped.length,
      total: metadataArray.length,
    },
    results: results,
  };
}
