/**
 * Impact Processor - Analyzes file changes and determines impact significance
 * This is the core engine for automatic impact tracking across the monorepo
 */

import path from "path";
import { createLogger } from "../utils/logger.js";

const logger = createLogger("ImpactProcessor");

/**
 * Main Impact Processor class
 * Handles analysis of file changes and generation of impact records
 */
export class ImpactProcessor {
  constructor(config = {}) {
    this.config = {
      monorepoRoot: config.monorepoRoot || process.cwd(),
      excludePatterns: config.excludePatterns || [
        "node_modules/**",
        ".git/**",
        "**/*.log",
        "**/dist/**",
        "**/.turbo/**",
      ],
      ...config,
    };
  }

  /**
   * Process a file change event and determine if it should generate impact records
   * @param {FileChangeEvent} event - The file change event
   * @returns {Promise<ImpactRecord[]>} Array of impact records to create
   */
  async processFileChange(event) {
    try {
      logger.debug(`Processing file change: ${event.type} ${event.filePath}`);

      // Check if we should track this impact
      if (!this.shouldTrackImpact(event)) {
        logger.debug(`Skipping impact tracking for ${event.filePath}`);
        return [];
      }

      // Determine affected apps
      const affectedApps = this.determineAffectedApps(event.filePath);

      // Generate description with context
      const description = this.generateDescription(event);

      // Create impact record
      const impactRecord = {
        filePath: this.getRelativePath(event.filePath),
        changeType: event.type,
        affectedApps,
        description,
        timestamp: event.timestamp || new Date(),
        userId: process.env.USER || "system",
        autoGenerated: true,
      };

      logger.info(`Generated impact record for ${event.filePath}`, {
        changeType: event.type,
        affectedApps,
      });

      return [impactRecord];
    } catch (error) {
      logger.error(
        `Error processing file change for ${event.filePath}:`,
        error
      );
      return [];
    }
  }

  /**
   * Determine which apps are affected by a file change
   * @param {string} filePath - The path of the changed file
   * @returns {string[]} Array of affected app names
   */
  determineAffectedApps(filePath) {
    const relativePath = this.getRelativePath(filePath);
    const affectedApps = [];

    // Direct app changes
    if (relativePath.startsWith("apps/")) {
      const appMatch = relativePath.match(/^apps\/([^\/]+)/);
      if (appMatch) {
        affectedApps.push(appMatch[1]);
      }
    }

    // Shared package changes affect multiple apps
    if (relativePath.startsWith("packages/shared-imports")) {
      affectedApps.push(
        "wf-client",
        "wf-admin",
        "wf-plan-management",
        "wf-server"
      );
    }

    // Database changes affect all apps
    if (relativePath.startsWith("sql/database")) {
      affectedApps.push(
        "wf-server",
        "wf-client",
        "wf-admin",
        "wf-plan-management"
      );
    }

    // EventType changes
    if (
      relativePath.includes("eventTypes") ||
      relativePath.includes("events/")
    ) {
      affectedApps.push(
        "wf-client",
        "wf-admin",
        "wf-plan-management",
        "wf-server"
      );
    }

    // Auth changes
    if (relativePath.includes("auth") || relativePath.includes("Auth")) {
      affectedApps.push("wf-client", "wf-admin", "wf-plan-management");
    }

    return [...new Set(affectedApps)]; // Remove duplicates
  }

  /**
   * Generate a descriptive message for the impact record
   * @param {FileChangeEvent} event - The file change event
   * @returns {string} Human-readable description of the change
   */
  generateDescription(event) {
    const relativePath = this.getRelativePath(event.filePath);
    const fileName = path.basename(event.filePath);
    const fileExt = path.extname(fileName);

    // Base description with change type
    let description = `${event.type}: ${relativePath}`;

    // Add context based on file location and type
    if (relativePath.startsWith("packages/shared-imports")) {
      description += " - Shared utility change affecting multiple apps";
    }

    if (
      relativePath.includes("eventTypes") ||
      relativePath.includes("events/")
    ) {
      description +=
        " - EventType modification may impact client/server communication";
    }

    if (relativePath.startsWith("sql/database")) {
      description += " - Database schema change requiring app updates";
    }

    if (fileExt === ".jsx" || fileExt === ".js") {
      description += " - JavaScript/React component change";
    }

    if (relativePath.includes("workflow")) {
      description += " - Workflow configuration change";
    }

    if (relativePath.includes("display")) {
      description += " - UI display configuration change";
    }

    return description;
  }

  /**
   * Determine if a file change should be tracked as an impact
   * @param {FileChangeEvent} event - The file change event
   * @returns {boolean} True if the change should be tracked
   */
  shouldTrackImpact(event) {
    const relativePath = this.getRelativePath(event.filePath);

    // Check exclude patterns
    for (const pattern of this.config.excludePatterns) {
      if (this.matchesPattern(relativePath, pattern)) {
        return false;
      }
    }

    // Only track certain file types
    const trackableExtensions = [
      ".js",
      ".jsx",
      ".ts",
      ".tsx",
      ".sql",
      ".json",
      ".md",
    ];
    const fileExt = path.extname(event.filePath);

    if (!trackableExtensions.includes(fileExt)) {
      return false;
    }

    // Don't track temporary or backup files
    if (relativePath.includes(".tmp") || relativePath.includes(".bak")) {
      return false;
    }

    return true;
  }

  /**
   * Get relative path from monorepo root
   * @param {string} filePath - Absolute file path
   * @returns {string} Relative path from monorepo root
   */
  getRelativePath(filePath) {
    return path.relative(this.config.monorepoRoot, filePath);
  }

  /**
   * Check if a path matches a glob-like pattern
   * @param {string} filePath - The file path to check
   * @param {string} pattern - The pattern to match against
   * @returns {boolean} True if the path matches the pattern
   */
  matchesPattern(filePath, pattern) {
    // Simple glob pattern matching
    const regexPattern = pattern
      .replace(/\*\*/g, ".*")
      .replace(/\*/g, "[^/]*")
      .replace(/\?/g, ".");

    const regex = new RegExp(`^${regexPattern}$`);
    return regex.test(filePath);
  }
}

/**
 * File Change Event interface
 * @typedef {Object} FileChangeEvent
 * @property {'CREATE'|'MODIFY'|'DELETE'} type - Type of file change
 * @property {string} filePath - Absolute path to the changed file
 * @property {Date} timestamp - When the change occurred
 * @property {number} [size] - File size after change
 */

/**
 * Impact Record interface
 * @typedef {Object} ImpactRecord
 * @property {number} [planId] - Associated plan ID (added by context analyzer)
 * @property {string} filePath - Relative path from monorepo root
 * @property {'CREATE'|'MODIFY'|'DELETE'} changeType - Type of change
 * @property {string[]} affectedApps - List of affected application names
 * @property {string} description - Human-readable description
 * @property {Date} timestamp - When the change occurred
 * @property {string} userId - User who made the change
 * @property {string} [batchId] - Batch ID for grouped changes
 * @property {boolean} autoGenerated - True for automatically tracked impacts
 */

export default ImpactProcessor;
