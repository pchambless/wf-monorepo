import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Get app name from command line args (default to client)
const appName = process.argv[2] || 'client';

// Dynamic import of eventTypes
const { EVENTS } = await import('../../../../shared-imports/src/events/client/eventTypes.js');

/**
 * Page Index Generator for WhatsFresh
 * 
 * This tool generates React component index.js files that import
 * their corresponding pageMap.js from the local config.
 * 
 * Usage:
 * node genPageIndex.js [app] [entityName]     # Generate for a single entity
 * node genPageIndex.js [app] --all           # Generate for all entities
 * node genPageIndex.js [app] --force         # Force overwrite of existing files
 */

// Process command line args
const entityArg = process.argv[3]; // Third argument is the entity name
const force = process.argv.includes('--force');
const generateAll = entityArg === '--all';

// Create eventTypes map for easy lookup
const eventTypesMap = {};
EVENTS.forEach(event => {
  eventTypesMap[event.eventType] = event;
});

if (!entityArg) {
  console.error(`Please provide an entity name or --all flag for app: ${appName}`);
  console.error(`Available entities: ${Object.keys(eventTypesMap).filter(name =>
    eventTypesMap[name].category && eventTypesMap[name].category.startsWith('page:')).join(', ')}`);
  process.exit(1);
}

// Function to generate a single index.js file
function generateIndexFile(entityName) {
  const event = eventTypesMap[entityName];

  // Skip entities that don't have proper event information
  if (!event) {
    console.log(`Skipping ${entityName} - event not found in eventTypes`);
    return false;
  }

  // Skip non-page events
  if (!event.category || !event.category.startsWith('page:')) {
    console.log(`Skipping ${entityName} - not a page event (category: ${event.category})`);
    return false;
  }

  // Use direct eventType â†’ folder mapping (simplified architecture)
  // entityName (e.g., "ingrTypeList") becomes the folder name directly
  const dirPath = entityName;

  // For logging, use the readable title from eventTypes when available
  const loggerName = event.title || entityName;

  // Extract layout component from category (e.g., 'page:CrudLayout' -> 'CrudLayout')
  const layoutComponent = event.category.split(':')[1] || 'CrudLayout';

  // Layout mapping - shared vs local client layouts
  const layoutMapping = {
    'MainLayout': { 
      import: "import { MainLayout } from '@whatsfresh/shared-imports/jsx';",
      component: 'MainLayout'
    },
    'CrudLayout': { 
      import: "import { CrudLayout } from '@whatsfresh/shared-imports/jsx';",
      component: 'CrudLayout'
    },
    'AuthLayout': { 
      import: "import AuthLayout from '../../layouts/AuthLayout';",
      component: 'AuthLayout'
    },
    'RecipeLayout': { 
      import: "import RecipeLayout from '../../layouts/RecipeLayout';",
      component: 'RecipeLayout'
    },
    'MappingLayout': { 
      import: "import BatchMapping from '../../layouts/BatchMapping';",
      component: 'BatchMapping'  // Maps to existing BatchMapping.jsx
    }
  };

  // Get the correct import and component name
  const layoutConfig = layoutMapping[layoutComponent] || layoutMapping['CrudLayout'];
  const { import: importStatement, component: layoutComponentName } = layoutConfig;

  // Create the target directory
  const targetDir = path.resolve(__dirname, '../../../../../apps/wf-client/src/pages', dirPath);
  if (!fs.existsSync(targetDir)) {
    fs.mkdirSync(targetDir, { recursive: true });
    console.log(`Created directory: ${targetDir}`);
  }

  // Create the index.js content - clean architecture with no external stores
  const indexContent = `import React from 'react';
${importStatement}
import pageMap from './pageMap';


/**
 * ${loggerName} Page
 * Generated by DevTools - Simple wrapper around ${layoutComponentName}
 * All data fetching, state management, and UI handled internally by ${layoutComponentName}
 */
const ${entityName} = () => {
  return <${layoutComponentName} pageMap={pageMap} />;
};

export default ${entityName};
`;

  // Write the file
  const targetFile = path.join(targetDir, 'index.jsx');
  const fileExists = fs.existsSync(targetFile);

  if (!fileExists || force) {
    fs.writeFileSync(targetFile, indexContent);
    console.log(`${fileExists ? 'Updated' : 'Created'}: ${targetFile}`);
    return true;
  } else {
    console.log(`Skipped: ${targetFile} (use --force to overwrite)`);
    return false;
  }
}

// Generate for a single entity or all entities
if (generateAll) {
  console.log('Generating index.jsx files for all entities...');
  let count = 0;

  // Get valid entities based on eventTypes (only page events)
  const validEntities = Object.keys(eventTypesMap).filter(name => {
    const event = eventTypesMap[name];
    return event.category && event.category.startsWith('page:');
  });

  for (const entityName of validEntities) {
    if (generateIndexFile(entityName)) {
      count++;
    }
  }

  console.log(`Generation complete! Created/updated ${count} index.jsx files.`);
} else {
  console.log(`Generating index.jsx for entity: ${entityArg}`);
  if (!eventTypesMap[entityArg]) {
    console.error(`Error: Entity "${entityArg}" not found in eventTypes`);
    process.exit(1);
  }

  generateIndexFile(entityArg);
  console.log('Done!');
}