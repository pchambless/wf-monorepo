
Tip: Use Plan Mode to prepare for a complex request before making changes. Press shift+tab twice to enable.

Triggers Tab Implementation & Database Schema Fixes - 2025-10-13

  Focus: Built full Triggers tab UI with class/action builder, fixed trigger param_schemas, implemented modal editing pattern

  ---
  ✅ Major Accomplishments

  1. Fixed All Trigger Param Schemas

  Updated 8 triggers in MySQL with corrected JSON schemas:
  - execEvent (id: 12) - Fixed invalid "text" type → proper object with qryName
  - execDML (id: 19) - Changed where → primaryKey to match actual API
  - setVals (id: 1) - Changed to array of param objects for multiple values
  - visible (id: 3) - Added array support for batch show/hide with explicit boolean state
  - closeModal/openModal (id: 20, 21) - Fixed required field placement
  - reload (id: 15) - Added proper componentId property
  - userLogin (id: 2) - Added required fields validation

  All schemas now:
  - ✅ Valid JSON Schema syntax
  - ✅ Match actual API signatures
  - ✅ Include required fields
  - ✅ Have clear descriptions for UI generation

  2. Built Complete Triggers Tab UI

  Created TriggerBuilder.jsx (/apps/studio/src/components/PropertyEditors/TriggerBuilder.jsx)
  - Class Grid - Shows all trigger classes for component with action counts
  - Class Dropdown - Populated from triggers table where trigType='class'
    - Filters out already-used classes
    - Shows "DOM" badge for DOM events (is_dom_event=1)
    - Tooltip with description on hover
  - Action Grid - Shows actions for selected class with order, action name, params preview
  - WorkflowTriggers Preview - Clean JSON format matching production structure
  - Error Handling - Graceful handling of invalid JSON in content field

  3. Implemented Modal Editing Pattern

  ComponentPropertiesPanel.jsx updated:
  - Clicking "Triggers" tab opens full-screen modal (90vw x 85vh)
  - Large workspace for complex trigger building
  - Click outside or X button to close
  - Component name shown in modal header
  - Pattern ready to apply to other tabs (Props, Query, Preview)

  4. Architecture Decisions

  Classes are Virtual:
  - No separate classes table - classes emerge from grouping eventTriggers by class column
  - Delete last action → class disappears automatically
  - Add class → Creates first empty action with that class name
  - Master class list in triggers table (trigType='class') for validation

  Save-to-MySQL Strategy:
  - Each action INSERT/UPDATE/DELETE syncs immediately to MySQL
  - Classes appear/disappear in real-time
  - No draft mode for triggers

  ---
  📊 Statistics

  - Files created: 1 (TriggerBuilder.jsx)
  - Files modified: 2 (ComponentPropertiesPanel.jsx, TriggerBuilder.jsx)
  - SQL updates: 8 trigger param_schemas corrected
  - Functions added: 5 (loadAvailableTriggers, loadTriggers, buildWorkflowPreview, handleAddClass, handleSelectClass)
  - UI components: 4 sections (Class Grid, Class Dropdown, Action Grid, WorkflowTriggers Preview)
  - Lines of code: ~370 (TriggerBuilder.jsx)

  ---
  🚀 Next Steps

  Immediate (Next Session)

  1. Add Action functionality - Implement "+ Add Action" with dropdown from availableTriggers
  2. Dynamic Param Builder - Use param_schema to generate input fields for each action type
  3. Edit Action - Click ✎ button to edit existing action params
  4. Delete Action - Click × button with immediate MySQL sync
  5. Order Management - Drag-and-drop or up/down arrows to reorder actions (updates ordr column)

  Short Term

  6. Sync to MySQL - Wire up all CRUD operations to sync immediately
  7. Param Validation - Validate params against param_schema before save
  8. Example Templates - Use example field from triggers table to pre-populate params
  9. Action Templates - Common patterns like "setVal + refresh" as quick-add options
  10. Test with real triggers - Create onChange → setVals + refresh workflow

  Future

  11. Apply modal pattern to other tabs - Props, Query, Preview tabs in modals
  12. Bulk operations - Copy/paste entire trigger classes between components
  13. Trigger library - Save common trigger patterns as reusable templates
  14. Visual workflow builder - Drag-and-drop action blocks instead of forms
  15. Trigger testing - Test button to execute trigger without deploying

  ---
  💡 Key Learnings

  Triggers Table Structure

  Two trigTypes in one table:
  triggers table:
  - trigType = 'class' → onLoad, onChange, onClick (7 classes)
  - trigType = 'action' → setVals, execEvent, refresh (14 actions)
  - param_schema → JSON Schema for validation
  - example → Sample JSON for pre-population
  - is_dom_event → 1 for DOM events, 0 for custom events

  Benefits:
  - Single source of truth for valid classes and actions
  - Schema-driven UI generation
  - Easy to add new trigger types without code changes

  Classes Are Virtual Groupings

  Key insight: Classes don't have their own table - they're just a grouping field
  -- No classes table! Classes emerge from:
  SELECT DISTINCT class FROM eventTriggers WHERE xref_id = X

  Implications:
  - Delete last action → class disappears (no orphan classes)
  - Can't have empty classes (must have at least 1 action)
  - Class validation against triggers.trigType='class' prevents typos

  Modal Pattern for Complex UIs

  Decision: Open complex tabs in modals instead of cramped panel
  // Click tab → Opens modal
  <button onClick={() => setShowTriggersModal(true)}>Triggers</button>

  // Full-screen workspace
  <div style={styles.modalOverlay}>
    <div style={styles.modalContent}> {/* 90vw x 85vh */}
      <TriggerBuilder component={selectedComponent} />
    </div>
  </div>

  Why this works:
  - More horizontal space for side-by-side layouts
  - Can expand vertically without panel constraints
  - Dedicated focus on complex task
  - Easily apply to Props, Query tabs next

  WorkflowTriggers Output Format

  Clean JSON structure for pageConfig generation:
  {
    "workflowTriggers": {
      "onChange": [
        { "action": "setVals", "params": {"ingrTypeID": "{{selected.id}}"} },
        { "action": "refresh", "params": ["ingrTypeForm"] }
      ],
      "onRefresh": [
        { "action": "execEvent", "params": "ingrTypeList" }
      ]
    }
  }

  Format rules:
  - Classes are object keys (onChange, onLoad, etc.)
  - Actions are arrays ordered by ordr column
  - Each action has action name and params (varies by action type)
  - ordr column used for sorting but not included in output

  Param Schema Validation Strategy

  Use JSON Schema for dynamic form generation:
  // Action: setVals
  param_schema: {
    "type": "array",
    "items": {
      "type": "object",
      "properties": {
        "paramName": {"type": "string"},
        "paramVal": {"type": "any"}
      },
      "required": ["paramName", "paramVal"]
    }
  }

  // UI generates: Array of {paramName, paramVal} input pairs

  Next step: Build ParamBuilder component that reads param_schema and generates appropriate inputs (text, select, array, object)

  ---
  📝 Code Snippets

  Load Classes from Triggers Table

  const loadAvailableTriggers = async () => {
    const actionTriggers = await db.triggers
      .where('trigType').equals('action')
      .toArray();
    const classTriggers = await db.triggers
      .where('trigType').equals('class')
      .toArray();

    setAvailableTriggers(actionTriggers);
    setAvailableClasses(classTriggers);
  };

  Build WorkflowTriggers Preview

  const buildWorkflowPreview = (grouped) => {
    const workflow = {};
    Object.keys(grouped).forEach(cls => {
      workflow[cls] = grouped[cls].map(t => {
        let params = {};
        try {
          params = JSON.parse(t.content || '{}');
        } catch (e) {
          params = t.content || {}; // Handle invalid JSON
        }
        return { action: t.action, params };
      });
    });
    setWorkflowPreview(workflow);
  };

  Class Dropdown with DOM Badge

  <div style={styles.dropdown}>
    {availableClasses
      .filter(c => !classes.includes(c.name))
      .map(cls => (
        <div
          key={cls.id}
          onClick={() => handleAddClass(cls.name)}
          style={styles.dropdownItem}
          title={cls.description}
        >
          <span>{cls.name}</span>
          {cls.is_dom_event === 1 && <span style={styles.domBadge}>DOM</span>}
        </div>
      ))}
  </div>

  Modal Pattern

  // State
  const [showTriggersModal, setShowTriggersModal] = useState(false);

  // Open on tab click
  <button onClick={() => setShowTriggersModal(true)}>Triggers</button>

  // Modal overlay
  {showTriggersModal && (
    <div style={styles.modalOverlay} onClick={() => setShowTriggersModal(false)}>
      <div style={styles.modalContent} onClick={(e) => e.stopPropagation()}>
        <div style={styles.modalHeader}>
          <h2>Triggers - {component.comp_name}</h2>
          <button onClick={() => setShowTriggersModal(false)}>✕</button>
        </div>
        <div style={styles.modalBody}>
          <TriggerBuilder component={component} />
        </div>
      </div>
    </div>
  )}

  ---
  Status: ✅ UI skeleton complete with class management. Ready to implement Add/Edit/Delete action functionality with param schema-driven form generation. Modal pattern working well
  and ready to extend to other tabs.