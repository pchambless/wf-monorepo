IndexedDB Modularization & Save-to-MySQL Architecture - 2025-10-13

  Focus: Fixed modularization bugs, eliminated redundant utilities, established save-to-MySQL-immediately workflow

  ---
  ✅ Major Accomplishments

  1. Fixed Critical Sync Bugs

  - propSaver.js - Converted from bundled JSON props to individual eventProps records
    - Was saving all props as single JSON blob to eventComp_xref.props column (OLD)
    - Now saves each prop as separate row in api_wf.eventProps table (NEW)
    - Fixed execDml signature - uses (operation, data) not single object
    - Fixed UPDATE primaryKey - keeps id in data object for sqlBuilder to find
  - syncOps.js - Fixed execDml calls to match shared-imports signature
  - SQL Builder compatibility - Discovered buildUpdateSQL looks for primaryKey IN data object (line 35)

  2. Eliminated Redundant Utilities

  Deleted 6 legacy files:
  - ❌ propSaver.js → Use modular eventProps/ operations + syncOps.js
  - ❌ triggerSaver.js → Use modular eventTriggers/ operations + syncOps.js
  - ❌ componentSaver.js → Use modular eventComp_xref/ operations + syncOps.js
  - ❌ propUpdater.js → Direct IndexedDB updates via modular operations
  - ❌ triggerUpdater.js → Direct IndexedDB updates via modular operations
  - ❌ studioSaveWorkflow.js → Just use syncToMySQL() from syncOps
  - ❌ syncWorkflow.js → Use syncOps.js instead
  - ❌ pageDraftWorkflow.js → No draft mode - immediate MySQL save

  Updated imports across:
  - ComponentPropertiesPanel.jsx - Now uses upsertPropByName() and direct IndexedDB queries
  - PageDraftControls.jsx - Now uses syncToMySQL() and hasPendingChanges()
  - SyncControls.jsx - Now uses syncToMySQL(), getPendingChanges(), clearAllDMLFlags()

  3. Established Save-to-MySQL Architecture

  Key Decision: MySQL = Staging, PageConfig = Production
  - ✅ Changes saved to MySQL immediately as users edit
  - ✅ Studio reads from MySQL for editing/preview
  - ✅ genPageConfig reads MySQL → generates pageConfig.json for production
  - ✅ Production apps read static pageConfig.json (never query MySQL directly)
  - ✅ User controls deployment via genPageConfig button

  Benefits:
  - No data loss - changes persisted immediately
  - Preview anytime from IndexedDB
  - Iterative editing without affecting production
  - Rollback safety - just don't run genPageConfig

  4. Schema Discovery Enhancement

  - Removed defaultHidden from stored proc - Developer must explicitly set visibility
  - Cleaner contract: stored proc provides data structure, developer provides UI intent
  - Visibility controlled via columnOverrides: { id: { hidden: true } }

  ---
  📊 Statistics

  - Files deleted: 8 (legacy utilities)
  - Files modified: 6 (ComponentPropertiesPanel, PageDraftControls, SyncControls, propSaver, syncOps, operations/index)
  - Bugs fixed: 4
    a. propSaver using wrong architecture (JSON blob vs individual records)
    b. execDml signature mismatch (object vs operation+data params)
    c. UPDATE primaryKey not in data object
    d. Missing imports after utility deletion
  - Architecture decisions: 2
    a. Save-to-MySQL-immediately workflow (no draft mode)
    b. Remove defaultHidden from schema generation

  ---
  🚀 Next Steps

  Immediate (Next Session)

  1. Test full CRUD workflow - Create component, edit props/triggers, update, delete
  2. Test cascading deletes - Verify cascade/orphan/prevent strategies work
  3. Test genPageConfig - Ensure MySQL → pageConfig.json generation works with new prop structure
  4. Update session doc - Add notes about save-to-MySQL architecture

  Short Term

  5. Apply same pattern to triggers - Ensure trigger sync works with new modular operations
  6. Add prop helper utility - Create loadPropsAsObject(xref_id) to reduce code duplication (used 3x in ComponentPropertiesPanel)
  7. Test with multiple components - Verify parent/child relationships work correctly
  8. Performance test - Check if immediate MySQL saves cause latency issues

  Future

  9. Auto-save on blur - Consider auto-syncing after field edits instead of manual Save button
  10. Optimistic UI updates - Show changes immediately, sync in background
  11. Conflict resolution - Handle multiple users editing same component
  12. Undo/Redo system - Track changes before MySQL sync for rollback capability

  ---
  💡 Key Learnings

  Save-to-MySQL-Immediately Architecture

  Pattern: IndexedDB (editing) → MySQL (staging) → pageConfig.json (production)
  - MySQL is not production - it's a staging/development database
  - Production apps never query MySQL - they read cached pageConfig
  - genPageConfig is the "deploy" button that publishes changes
  - This enables safe iterative development with zero production impact

  execDml Signature in shared-imports

  // Exported signature (bound with config)
  execDml(operation, data)
  // operation - unused string identifier
  // data - actual DML payload { method, table, data, primaryKey }

  // Example
  await execDml('eventPropsUpdate', {
    method: 'UPDATE',
    table: 'api_wf.eventProps',
    data: { id: 46, xref_id: 56, paramName: 'columns', paramVal: '[...]' },
    primaryKey: 'id'
  });

  SQL Builder Expects PrimaryKey IN Data

  Critical Discovery: buildUpdateSQL looks for primaryKey inside the data object
  // sqlBuilder.js line 35-36
  Object.entries(data).forEach(([key, value]) => {
    if (key === primaryKey) {
      whereValue = value; // Extracts id from data, not from separate param
    }
  });

  Wrong approach:
  const { idbID, _dmlMethod, id, ...data } = prop; // id stripped out!
  await execDml('update', { data, primaryKey: { id } }); // id not in data = WHERE id = NULL

  Correct approach:
  const { idbID, _dmlMethod, ...data } = prop; // Keep id in data!
  await execDml('update', { data, primaryKey: 'id' }); // id IN data = WHERE id = 46

  Modular Operations Pattern

  Structure:
  db/operations/
  ├── eventComp_xref/
  │   ├── insert.js
  │   ├── update.js
  │   ├── delete.js
  │   ├── read.js
  │   └── index.js (re-exports all)
  ├── eventProps/
  ├── eventTriggers/
  ├── componentOps.js (backward compatibility re-exports)
  └── syncOps.js (syncs all pending changes)

  Benefits:
  - Single source of truth for each operation
  - Easy to find and maintain
  - Consistent error handling
  - Eliminates utility file duplication

  Props as Individual Records vs JSON Blob

  OLD: All props bundled into single JSON column
  UPDATE eventComp_xref SET props = '{"columns":[...],"columnOverrides":{...}}' WHERE id = 56

  NEW: Each prop is a separate record
  INSERT INTO eventProps (xref_id, paramName, paramVal) VALUES (56, 'columns', '[...]');
  INSERT INTO eventProps (xref_id, paramName, paramVal) VALUES (56, 'columnOverrides', '{...}');

  Advantages:
  - Query individual props
  - Audit trail per prop
  - Efficient partial updates
  - Better indexing
  - Easier to debug

  ---
  📝 Code Snippets

  Load Props Helper Pattern

  // Used 3x in ComponentPropertiesPanel - candidate for utility function
  const propsArray = await db.eventProps.where('xref_id').equals(xref_id).toArray();
  const props = {};
  propsArray.forEach(p => {
    try { props[p.paramName] = JSON.parse(p.paramVal); }
    catch { props[p.paramName] = p.paramVal; }
  });

  Sync Pattern

  // Edit - marks for sync
  await upsertPropByName(xref_id, 'columns', fields);

  // Sync all pending changes
  const results = await syncToMySQL();
  const successCount = results.filter(r => r.success).length;

  ## Next Steps:  
    1.  Modularize Reference file workflows.
    2.  Triggers Tab requirements:  See github Issue #8
    3.  Analyze the Event Preview content: See github Issue #7
    4.  execDML processing: See github Issue #9

    All of these requirements were created with initial Paul thoughts... 



  ---
  Status: ✅ Modularization complete. Save-to-MySQL workflow functional. Ready for full CRUD testing and genPageConfig integration testing.

