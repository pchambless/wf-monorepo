#!/bin/bash

# Store Kiro session summary in plan_communications table
# This creates a proper AI coordination record

curl -X POST http://localhost:3001/api/execDML \
  -H "Content-Type: application/json" \
  -d '{
    "qrySQL": "INSERT INTO api_wf.plan_communications (plan_id, from_agent, to_agent, type, subject, message, status, created_by) VALUES (0, \"kiro\", \"claude\", \"summary\", \"Module Dependency Database Population System - Implementation Complete\", \"# Kiro Session Summary - 2025-10-19\\n\\n**Focus:** Module Dependency Database Population System Implementation\\n**Primary AI:** Kiro\\n\\n---\\n\\n## âœ… Major Accomplishments\\n\\n### 1. Fixed Stored Procedure Parameter Alignment\\n- **Issue**: Parameter name mismatches between eventSQL, JavaScript, and stored procedures\\n- **Solution**: Aligned all parameter names (analysis_json, firstName) across the entire stack\\n- **Result**: Both sp_module_load and sp_module_map now work correctly\\n\\n### 2. Simplified JSON Processing Architecture\\n- **Removed**: Complex JSON_TABLE cursor approach that was causing SQL errors\\n- **Implemented**: Simple JSON array iteration using JSON_LENGTH() and JSON_EXTRACT()\\n- **Pattern**: Same approach for both stored procedures for consistency\\n\\n### 3. Database Schema Alignment\\n- **Fixed**: Column name mismatches (module_id/parent_id vs from_module_id/to_module_id)\\n- **Added**: last_detected_at columns for filesystem sync detection\\n- **Verified**: All stored procedures match actual database table structure\\n\\n### 4. Successful Two-Phase Population\\n- **Phase 1**: Module loading (91 modules) âœ…\\n- **Phase 2**: Dependency mapping (158 dependencies) âœ…\\n- **Architecture**: Clean separation between module creation and relationship mapping\\n\\n### 5. Created Comprehensive Database Views\\n- **vw_modules_with_blast_radius**: Calculates blast radius based on dependent counts\\n- **vw_dependencies_with_types**: Derives internal/external types from package comparison\\n- **vw_module_impact_analysis**: Complete impact analysis with classifications\\n\\n---\\n\\n## ðŸ“Š Statistics\\n\\n- Files modified: 8 (stored procedures, tables, views, populate script)\\n- Database objects: 2 tables updated, 2 stored procedures fixed, 3 views created\\n- Test results: 91 modules and 158 dependencies processed successfully\\n- Population time: ~2 seconds for full server analysis\\n\\n---\\n\\n## ðŸš€ Next Steps\\n\\n### Immediate (Next Session)\\n1. Apply database views to MySQL instance\\n2. Test view queries for impact analysis\\n3. Create eventSQL entries for view access from applications\\n\\n### Short Term\\n4. Integrate with plan_impacts workflow for change impact analysis\\n5. Add studio analysis population using same pattern\\n6. Create cleanup procedures for stale last_detected_at records\\n\\n---\\n\\n## ðŸ’¡ Key Learnings\\n\\n### Parameter Binding\\n- **eventSQL parameter names** are the source of truth\\n- **Easier to change eventSQL** than coordinate across multiple files\\n- **Direct parameter passing** works better than context store for this use case\\n\\n### Database Design\\n- **Views for derived data** keeps base tables simple\\n- **Soft delete pattern** essential for filesystem sync\\n- **Manual JSON parsing** more reliable than JSON_TABLE for complex operations\\n\\n---\\n\\n**Status:** Core module dependency system fully operational with comprehensive analysis views ready for integration.\", \"system\")"
  }' | jq '.'