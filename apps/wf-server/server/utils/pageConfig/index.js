/**
 * Database-Driven PageConfig Generator - Clean from scratch
 */

import { promises as fs } from 'fs';
import path from 'path';
import stringify from 'json-stringify-pretty-compact';
import logger from "../logger.js";

const codeName = "[database-genPageConfig.js]";
const STUDIO_PREVIEW_PATH = "/home/paul/wf-monorepo-new/apps/wf-studio/src/preview";
const PREVIEW_ROUTES_FILE = "/home/paul/wf-monorepo-new/apps/wf-studio/src/config/preview-routes.js";

/**
 * Update preview routes manifest with new route entry
 */
async function updatePreviewRoutes(appName, pageName, pageTitle) {
  try {
    let routes = [];

    // Try to read existing routes
    try {
      const existingContent = await fs.readFile(PREVIEW_ROUTES_FILE, 'utf8');
      const match = existingContent.match(/export const PREVIEW_ROUTES = (\[[\s\S]*?\]);/);
      if (match) {
        routes = JSON.parse(match[1]);
      }
    } catch (error) {
      logger.debug(`${codeName} No existing preview-routes.js, creating new`);
    }

    // Add or update route entry
    const routePath = `/preview/${appName}/${pageName}`;
    const existingIndex = routes.findIndex(r => r.path === routePath);

    const routeEntry = {
      path: routePath,
      component: `preview/${appName}/${pageName}`,
      title: pageTitle,
      appName,
      pageName,
      generated: new Date().toISOString()
    };

    if (existingIndex >= 0) {
      routes[existingIndex] = routeEntry;
    } else {
      routes.push(routeEntry);
    }

    // Write updated routes file
    const routesContent = `/**
 * Preview Routes Manifest
 * AUTO-GENERATED by genPageConfig - DO NOT EDIT MANUALLY
 *
 * This file is automatically updated when pages are generated via genPageConfig.
 * Preview routes allow testing database-generated pages before deployment.
 */

export const PREVIEW_ROUTES = ${JSON.stringify(routes, null, 2)};
`;

    await fs.writeFile(PREVIEW_ROUTES_FILE, routesContent);
    logger.debug(`${codeName} Updated preview-routes.js with ${routes.length} routes`);

    return routeEntry;
  } catch (error) {
    logger.error(`${codeName} Error updating preview routes:`, error);
    throw error;
  }
}

/**
 * Generate mermaid chart from database hierarchy (excluding level -1)
 */
function generateMermaid(hierarchyData) {
  const lines = ['graph TD', ''];

  // Filter out level -1 (monorepo root)
  const filteredData = hierarchyData.filter(item => item.level >= 0);

  filteredData.forEach(item => {
    const nodeId = item.comp_name;
    const nodeLabel = `${nodeId}<br/>ctgry: [${item.template.toLowerCase()}]`;
    lines.push(`    ${nodeId}["${nodeLabel}"]`);

    const parent = filteredData.find(p => p.id === item.parent_id);
    if (parent) {
      lines.push(`    ${parent.comp_name} --> ${nodeId}`);
    }
  });

  lines.push('');
  lines.push('    %% Click handlers for Studio integration');
  filteredData.forEach(item => {
    lines.push(`    click ${item.comp_name} href "javascript:window.selectEventTypeTab(${item.id})"`);
  });

  return lines.join('\n');
}

/**
 * Convert flat hierarchy to nested pageConfig with enhanced props and triggers
 */
async function buildPageConfig(hierarchyData, userEmail = 'pc7900@gmail.com') {
  const rootComponent = hierarchyData.find(item => item.level === 0);
  if (!rootComponent) {
    throw new Error('No root component found');
  }

  // Parse JSON strings from database (enhancedProps and workflowTriggers come from sp_hier_structure)
  logger.debug(`${codeName} Processing ${hierarchyData.length} components from database`);

  for (const component of hierarchyData) {
    try {
      // Parse enhancedProps if it's a JSON string from database
      if (component.enhancedProps && typeof component.enhancedProps === 'string') {
        try {
          component.enhancedProps = JSON.parse(component.enhancedProps);
          logger.debug(`${codeName} Parsed enhancedProps for ${component.comp_name}: ${Object.keys(component.enhancedProps).length} props`);
        } catch (error) {
          logger.error(`${codeName} Error parsing enhancedProps for ${component.comp_name}:`, error);
          component.enhancedProps = null;
        }
      }

      // Parse workflowTriggers if it's a JSON string from database
      if (component.workflowTriggers && typeof component.workflowTriggers === 'string') {
        try {
          component.workflowTriggers = JSON.parse(component.workflowTriggers);
          logger.debug(`${codeName} Parsed workflowTriggers for ${component.comp_name}: ${Object.keys(component.workflowTriggers).length} trigger classes`);
        } catch (error) {
          logger.error(`${codeName} Error parsing workflowTriggers for ${component.comp_name}:`, error);
          component.workflowTriggers = null;
        }
      }
    } catch (error) {
      logger.error(`${codeName} Error processing component ${component.comp_name}:`, error);
    }
  }

  const buildChildren = (parentId, level) => {
    return hierarchyData
      .filter(item => item.parent_id === parentId && item.level === level)
      .filter(item => item.template !== 'ServerQuery') // UI only
      .map(item => {
        // Parse posOrder: "01,01;01,02" = rowStart,rowSpan;colStart,colSpan
        const [rowData, colData] = (item.posOrder || '00,00;00,00').split(';');
        const [rowStart, rowSpan] = rowData.split(',').map(n => parseInt(n));
        const [colStart, colSpan] = colData.split(',').map(n => parseInt(n));

        // Use enhanced props from eventProps table, fallback to old props
        let props = item.enhancedProps ||
          (typeof item.props === 'string' ? JSON.parse(item.props || '{}') : item.props || {});

        // CRITICAL: Remove workflowTriggers from props if they exist (they belong at component root, not in props)
        // This can happen if old props column still has workflowTriggers embedded
        if (props && typeof props === 'object') {
          const { workflowTriggers, ...cleanPropsOnly } = props;
          props = cleanPropsOnly;
        }

        const cleanProps = props;

        // Parse and merge styles: base_styles first, then override_styles
        let mergedStyles = null;
        try {
          const baseStyles = item.base_styles ? JSON.parse(item.base_styles) : {};
          const overrideStyles = item.override_styles ? JSON.parse(item.override_styles) : {};

          if (Object.keys(baseStyles).length > 0 || Object.keys(overrideStyles).length > 0) {
            mergedStyles = { ...baseStyles, ...overrideStyles };
          }
        } catch (error) {
          logger.error(`${codeName} Error parsing styles for ${item.comp_name}:`, error);
        }

        // Get existing child components first
        const existingChildren = hierarchyData.some(child => child.parent_id === item.id) ?
          buildChildren(item.id, level + 1) : [];

        let component = {
          id: item.comp_name,
          type: item.template.toLowerCase(),
          container: cleanProps.container || 'inline',
          position: rowStart > 0 || colStart > 0 ? {
            row: { start: rowStart, span: rowSpan },
            col: { start: colStart, span: colSpan }
          } : {},
          props: { ...cleanProps },
          ...(mergedStyles && { style: mergedStyles }),
          ...(item.workflowTriggers && { workflowTriggers: item.workflowTriggers }),
          ...(existingChildren.length > 0 && { components: existingChildren })
        };

        // Special handling: Expand forms with props.fields into component trees
        if (item.template.toLowerCase() === 'form' && cleanProps.fields && Array.isArray(cleanProps.fields)) {
          logger.debug(`${codeName} Expanding form ${item.comp_name} with ${cleanProps.fields.length} fields into component tree`);

          const formComponents = [];

          // Add form title if it exists
          if (cleanProps.title) {
            formComponents.push({
              id: `${item.comp_name}_title`,
              type: 'h3',
              textContent: cleanProps.title,
              style: { marginTop: 0 }
            });
          }

          // Convert each field to component tree
          cleanProps.fields.forEach((field, index) => {
            const fieldContainer = {
              id: `${item.comp_name}_field_${field.name}`,
              type: 'div',
              style: { marginBottom: '16px' },
              components: [
                {
                  id: `${item.comp_name}_label_${field.name}`,
                  type: 'label',
                  textContent: field.label + (field.required ? '*' : ''),
                  props: { htmlFor: field.name },
                  style: {
                    display: 'block',
                    marginBottom: '4px',
                    fontWeight: '500'
                  }
                },
                {
                  id: `${item.comp_name}_input_${field.name}`,
                  type: 'input',
                  props: {
                    name: field.name,
                    type: field.type,
                    placeholder: field.placeholder || '',
                    required: field.required || false
                  },
                  style: {
                    width: '100%',
                    padding: '8px 12px',
                    border: '1px solid #ccc',
                    borderRadius: '4px',
                    fontSize: '14px'
                  }
                }
              ]
            };
            formComponents.push(fieldContainer);
          });

          // Add existing child components (buttons, etc.) at the end
          formComponents.push(...existingChildren);

          // Remove props.fields and props.title, replace with component tree
          delete component.props.fields;
          delete component.props.title;
          component.components = formComponents;
        }

        // Special handling: Expand grids with props.columns into component trees
        if (item.template.toLowerCase() === 'grid' && cleanProps.columns && Array.isArray(cleanProps.columns)) {
          logger.debug(`${codeName} Expanding grid ${item.comp_name} with ${cleanProps.columns.length} columns into component tree`);

          const gridComponents = [];

          // Add grid title if it exists
          if (cleanProps.title) {
            gridComponents.push({
              id: `${item.comp_name}_title`,
              type: 'h2',
              textContent: cleanProps.title,
              style: { marginTop: 0, marginBottom: '16px' }
            });
          }

          // Create table structure
          const tableComponent = {
            id: `${item.comp_name}_table`,
            type: 'table',
            style: {
              width: '100%',
              borderCollapse: 'collapse',
              border: '1px solid #e0e0e0'
            },
            components: [
              // Table header
              {
                id: `${item.comp_name}_thead`,
                type: 'thead',
                style: { backgroundColor: '#f5f5f5' },
                components: [
                  {
                    id: `${item.comp_name}_headerRow`,
                    type: 'tr',
                    components: cleanProps.columns.map(col => ({
                      id: `${item.comp_name}_header_${col.field}`,
                      type: 'th',
                      textContent: col.header || col.field,
                      style: {
                        padding: '12px 8px',
                        textAlign: col.align || 'left',
                        borderBottom: '1px solid #e0e0e0',
                        fontWeight: '600',
                        width: col.width || 'auto'
                      }
                    }))
                  }
                ]
              },
              // Table body (will be populated by data)
              {
                id: `${item.comp_name}_tbody`,
                type: 'tbody',
                props: {
                  dataSource: props.serverQuery || 'authAppList', // Default to authAppList
                  rowKey: props.rowKey || 'id',
                  selectable: props.selectable !== false,
                  columns: props.columns
                },
                // Placeholder row for styling
                components: [
                  {
                    id: `${item.comp_name}_placeholderRow`,
                    type: 'tr',
                    style: { backgroundColor: '#fafafa' },
                    components: props.columns.map(col => ({
                      id: `${item.comp_name}_placeholder_${col.field}`,
                      type: 'td',
                      textContent: `{${col.field}}`,
                      style: {
                        padding: '8px',
                        borderBottom: '1px solid #e0e0e0',
                        cursor: props.selectable !== false ? 'pointer' : 'default'
                      }
                    }))
                  }
                ]
              }
            ]
          };

          gridComponents.push(tableComponent);

          // Add existing child components at the end
          gridComponents.push(...existingChildren);

          // Remove props.columns and props.title, replace with component tree
          delete component.props.columns;
          delete component.props.title;
          component.components = gridComponents;
        }

        // Note: workflowTriggers already added at component level during enhancement

        return component;
      });
  };

  const rootProps = typeof rootComponent.props === 'string' ? JSON.parse(rootComponent.props || '{}') : rootComponent.props || {};

  // Get app name for constructing default routePath
  const appComponent = hierarchyData.find(item => item.level === -1);
  const appName = appComponent ? appComponent.comp_name : '';
  const defaultRoutePath = appName ? `/${appName}/${rootComponent.comp_name}` : `/${rootComponent.comp_name}`;

  return {
    layout: "flex",
    components: buildChildren(rootComponent.id, 1),
    title: rootProps.title || rootComponent.comp_name,
    routePath: rootProps.routePath || defaultRoutePath,
    purpose: "Database-generated page configuration",
    cluster: "Page"
  };
}

/**
 * Generate pageConfig from database using pageID
 */
export async function genPageConfig(pageID) {
  logger.debug(`${codeName} Generating pageConfig for page xref ID: ${pageID}`);

  try {
    // Execute pageHierarchy ServerQuery (xref 39) with the pageID
    const { executeQuery } = await import('../dbUtils.js');

    // Execute stored procedure directly - sp_hier_structure
    const storedProcSQL = `CALL api_wf.sp_hier_structure(${pageID})`;
    const hierarchyResult = await executeQuery(storedProcSQL, 'GET');
    const hierarchyData = Array.isArray(hierarchyResult) && hierarchyResult.length > 0 ? hierarchyResult[0] : [];

    if (!hierarchyData || hierarchyData.length === 0) {
      throw new Error(`No hierarchy data found for page ID: ${pageID}`);
    }

    logger.debug(`${codeName} Loaded ${hierarchyData.length} components from database`);

    // Generate pageConfig and mermaid
    const pageConfig = await buildPageConfig(hierarchyData);
    const mermaidChart = generateMermaid(hierarchyData);

    // Extract app and page names from hierarchy data
    // Note: level -1 = App, level 0 = Page, level 1+ = Components
    const appComponent = hierarchyData.find(item => item.level === -1);   // App level (wf-login)
    const pageComponent = hierarchyData.find(item => item.level === 0);   // Page level (loginPage)

    if (!appComponent || !pageComponent) {
      throw new Error('Missing app or page component in hierarchy data');
    }

    // Map hierarchy names to studio preview structure
    // App level (-1): wf-login -> wf-login (keep as-is)
    // Page level (0): loginPage -> loginPage (keep as-is)
    const appName = appComponent.comp_name;  // wf-login
    const pageName = pageComponent.comp_name; // loginPage

    const pageConfigPath = path.join(STUDIO_PREVIEW_PATH, appName, pageName, 'pageConfig.json');
    const mermaidPath = path.join(STUDIO_PREVIEW_PATH, appName, pageName, 'pageMermaid.mmd');
    const indexPath = path.join(STUDIO_PREVIEW_PATH, appName, pageName, 'index.jsx');
    const targetDir = path.join(STUDIO_PREVIEW_PATH, appName, pageName);

    try {
      // Ensure directory exists
      await fs.mkdir(targetDir, { recursive: true });

      const formattedJson = stringify(pageConfig, { maxLength: 100, indent: 2 });
      await fs.writeFile(pageConfigPath, formattedJson);
      logger.debug(`${codeName} Saved pageConfig.json to ${pageConfigPath}`);
    } catch (error) {
      logger.warn(`${codeName} Could not save pageConfig.json: ${error.message}`);
    }

    try {
      await fs.writeFile(mermaidPath, mermaidChart);
      logger.debug(`${codeName} Saved pageMermaid.mmd to ${mermaidPath}`);
    } catch (error) {
      logger.warn(`${codeName} Could not save pageMermaid.mmd: ${error.message}`);
    }

    try {
      // Generate generic index.jsx template
      const indexTemplate = `import React, { useState, useEffect } from "react";
import DirectRenderer from '../../../rendering/DirectRenderer';
import pageConfig from "./pageConfig.json";

/**
 * ${pageName} - Database-generated page
 * Auto-generated by genPageConfig from database eventTypes
 */
const ${pageName} = () => {
  const [config, setConfig] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    setConfig(pageConfig);
    setLoading(false);
  }, []);

  if (loading) {
    return (
      <div style={{
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        height: "100vh",
        fontSize: "18px",
        color: "#666"
      }}>
        Loading ${pageName}...
      </div>
    );
  }

  return <DirectRenderer config={config} />;
};

export default ${pageName};
`;

      await fs.writeFile(indexPath, indexTemplate);
      logger.debug(`${codeName} Saved index.jsx to ${indexPath}`);
    } catch (error) {
      logger.warn(`${codeName} Could not save index.jsx: ${error.message}`);
    }

    // Update preview routes manifest
    let routeEntry = null;
    try {
      routeEntry = await updatePreviewRoutes(appName, pageName, pageConfig.title);
      logger.debug(`${codeName} Updated preview routes manifest`);
    } catch (error) {
      logger.warn(`${codeName} Could not update preview routes: ${error.message}`);
    }

    return {
      pageConfig,
      mermaidData: { chart: mermaidChart, totalComponents: hierarchyData.length },
      meta: {
        pageID,
        componentsGenerated: hierarchyData.length,
        generated: new Date().toISOString(),
        previewPath: targetDir,
        previewRoute: routeEntry,
        files: {
          pageConfig: pageConfigPath,
          mermaid: mermaidPath,
          index: indexPath
        }
      }
    };

  } catch (error) {
    logger.error(`${codeName} Error generating pageConfig:`, error);
    throw error;
  }
}