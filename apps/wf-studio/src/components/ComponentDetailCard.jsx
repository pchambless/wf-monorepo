import React from 'react';
import DataBindingCard from './cards/DataBindingCard.jsx';
import EventTypeRenderer from './EventTypeRenderer.jsx';
import { getCategoryOptions, getDetailViewForEventType } from '../config/componentCategories.js';
import '../styles/components/ComponentDetailCard.css';
import '../styles/components/EventTypeRenderer.css';

/**
 * Component Detail Card - Modularized from StudioPageRenderer
 * Shows selected eventType info with multiple expandable cards
 * LOADS REAL EVENTTYPE FILES - NO MOCK DATA
 * 
 * TODO: Refactor to ComponentDetailCard/ folder structure with individual card components
 */
const ComponentDetailCard = () => {
  const [selectedEventType, setSelectedEventType] = React.useState(null);
  const [eventTypeData, setEventTypeData] = React.useState(null);
  const [detailViewEventType, setDetailViewEventType] = React.useState(null);
  const [loading, setLoading] = React.useState(false);
  const [error, setError] = React.useState(null);
  const [categoryOptions, setCategoryOptions] = React.useState([]);

  // Load category options from shared config
  React.useEffect(() => {
    setCategoryOptions(getCategoryOptions());
  }, []);

  // Load appropriate detail view eventType when eventTypeData changes
  React.useEffect(() => {
    const loadDetailViewEventType = async () => {
      if (!eventTypeData) {
        setDetailViewEventType(null);
        return;
      }

      try {
        // Determine which detail view to use
        const detailViewName = getDetailViewForEventType(eventTypeData);
        console.log(`üéØ Using detail view: ${detailViewName} for eventType:`, eventTypeData.category);

        // Load the appropriate detail view eventType
        if (detailViewName === 'LeafComponentDetail') {
          const { leafComponentDetail } = await import('../eventTypes/studio/components/leafComponentDetail.js');
          setDetailViewEventType(leafComponentDetail);
        } else if (detailViewName === 'ContainerComponentDetail') {
          // TODO: Create containerComponentDetail.js
          console.log('‚è≥ ContainerComponentDetail not implemented yet');
          setDetailViewEventType(null);
        } else {
          console.warn(`‚ö†Ô∏è Unknown detail view: ${detailViewName}`);
          setDetailViewEventType(null);
        }
      } catch (error) {
        console.error('‚ùå Failed to load detail view eventType:', error);
        setDetailViewEventType(null);
      }
    };

    loadDetailViewEventType();
  }, [eventTypeData]);

  React.useEffect(() => {
    // Check for selected eventType from contextStore
    import('../stores/studioStore.js').then(({ getVal }) => {
      const eventType = getVal('selectedEventType');
      setSelectedEventType(eventType);

      // If we have an eventType name, load its actual data
      if (eventType && typeof eventType === 'string') {
        loadRealEventTypeData(eventType);
      }
    });

    // Poll for changes (simple approach)
    const interval = setInterval(() => {
      import('../stores/studioStore.js').then(({ getVal }) => {
        const eventType = getVal('selectedEventType');
        if (eventType !== selectedEventType) {
          setSelectedEventType(eventType);
          if (eventType && typeof eventType === 'string') {
            loadRealEventTypeData(eventType);
          }
        }
      });
    }, 1000);

    return () => clearInterval(interval);
  }, [selectedEventType]);

  const loadRealEventTypeData = async (eventTypeName) => {
    setLoading(true);
    setError(null);

    try {
      const { getVal } = await import('../stores/studioStore.js');
      const selectedApp = getVal('selectedApp') || 'plans';
      const selectedPage = getVal('selectedPage') || 'PlanManager';

      // Use bulletproof eventType discovery
      const { getEventType } = await import('../utils/eventTypeDiscovery');
      const eventTypeData = getEventType(eventTypeName, selectedApp, selectedPage);

      console.log('‚úÖ Loaded real eventType data via discovery:', eventTypeData);
      setEventTypeData(eventTypeData);

    } catch (error) {
      console.error(`‚ùå Failed to load eventType '${eventTypeName}':`, error);
      setError(`Failed to load eventType: ${error.message}`);
      setEventTypeData(null);
    } finally {
      setLoading(false);
    }
  };

  const handleEventTypeUpdate = (updatedData) => {
    console.log('üîÑ ComponentDetailCard - EventType updated:', updatedData);

    // Auto-generate eventType name from category + title
    let autoGeneratedName = selectedEventType;
    if (updatedData.category && updatedData.title) {
      // Convert title to camelCase and prepend category
      const titleCamelCase = updatedData.title
        .replace(/[^a-zA-Z0-9\s]/g, '') // Remove special chars
        .replace(/\s(.)/g, (match, letter) => letter.toUpperCase()) // camelCase
        .replace(/\s/g, '') // Remove remaining spaces
        .replace(/^./, letter => letter.toUpperCase()); // Capitalize first letter

      autoGeneratedName = updatedData.category + titleCamelCase;

      // Update the selectedEventType name for display
      setSelectedEventType(autoGeneratedName);
    }

    setEventTypeData(updatedData);

    // TODO: Save changes back to actual file with new name
    // TODO: Update contextStore if needed
  };

  const handleGenerateFields = async () => {
    if (!eventTypeData?.qry) {
      alert('EventType missing qry property - cannot generate fields');
      return;
    }

    setLoading(true);
    try {
      console.log(`üîÑ A1: Studio Generate Fields Button clicked for ${eventTypeData.title}`);

      // Import and use the unified workflow
      const { unifiedGenFieldsWorkflow } = await import('../workflows/unifiedGenFields.js');

      // W1 -> W7: Complete genFields process
      const result = await unifiedGenFieldsWorkflow.startGenFieldsProcess(eventTypeData);

      // Update state with enhanced eventType
      setEventTypeData(result.eventType);

      // Show success notification
      const { notification } = result;
      alert(`${notification.title}\n\n${notification.message}`);

    } catch (error) {
      console.error('‚ùå Unified genFields workflow failed:', error);
      alert(`Field generation failed: ${error.message}`);
    } finally {
      setLoading(false);
    }
  };

  if (!selectedEventType) {
    return (
      <div className="component-detail-container">
        <h4 className="component-detail-title">Component Detail</h4>
        <p className="component-detail-empty">
          Select an eventType from the sidebar to view and edit its properties.
        </p>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="component-detail-container">
        <h4 className="component-detail-title">Component Detail: {selectedEventType}</h4>
        <p>Loading real eventType data...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="component-detail-container">
        <h4 className="component-detail-title">Component Detail: {selectedEventType}</h4>
        <div style={{ color: 'red', padding: '12px', border: '1px solid red', borderRadius: '4px' }}>
          <strong>Error:</strong> {error}
        </div>
      </div>
    );
  }

  // Use EventTypeRenderer if we have a detail view eventType, otherwise fall back to legacy UI
  if (detailViewEventType) {
    return (
      <div className="component-detail-container">
        <EventTypeRenderer
          eventType={detailViewEventType}
          eventTypeData={eventTypeData}
          onUpdate={setEventTypeData}
        />
      </div>
    );
  }

  // Legacy UI fallback
  return (
    <div className="component-detail-container">
      <h4 className="component-detail-title">Component Detail: {selectedEventType}</h4>

      {/* 2-Column Card Layout */}
      <div className="component-detail-cards">
        {/* Basic Properties Card - Left Column */}
        <div className="basic-card">
          <div className="basic-card-header">
            <span className="card-icon">üîµ</span>
            <h3 className="card-title">Basic Properties</h3>
          </div>
          <div className="basic-card-content">
            <div className="property-field">
              <label className="property-label">EventType <span className="property-hint-inline">(read-only identifier)</span></label>
              <input
                type="text"
                value={selectedEventType}
                className="property-input"
                readOnly
                style={{ backgroundColor: '#f9fafb', color: '#6b7280' }}
              />
            </div>

            <div className="property-field">
              <label className="property-label">Category <span className="property-hint-inline">(component type)</span></label>
              <select
                value={eventTypeData?.category || ''}
                onChange={(e) => handleEventTypeUpdate({ ...eventTypeData, category: e.target.value })}
                className="property-input"
              >
                <option value="">Select category...</option>
                {categoryOptions.map(option => (
                  <option key={option.value} value={option.value} title={option.description}>
                    {option.label}
                  </option>
                ))}
              </select>
            </div>

            <div className="property-field">
              <label className="property-label">Title <span className="property-hint-inline">(display name)</span></label>
              <input
                type="text"
                value={eventTypeData?.title || ''}
                onChange={(e) => handleEventTypeUpdate({ ...eventTypeData, title: e.target.value })}
                className="property-input"
                placeholder="User-friendly name"
              />
            </div>

            <div className="property-field">
              <label className="property-label">Cluster <span className="property-hint-inline">(data grouping)</span></label>
              <input
                type="text"
                value={eventTypeData?.cluster || ''}
                onChange={(e) => handleEventTypeUpdate({ ...eventTypeData, cluster: e.target.value })}
                className="property-input"
                placeholder="PLANS, USERS, etc."
              />
            </div>

            <div className="property-field">
              <label className="property-label">Purpose <span className="property-hint-inline">(brief description)</span></label>
              <textarea
                value={eventTypeData?.purpose || ''}
                onChange={(e) => handleEventTypeUpdate({ ...eventTypeData, purpose: e.target.value })}
                className="property-textarea"
                placeholder="Describe what this eventType does..."
                rows={2}
              />
            </div>
          </div>
        </div>

        {/* Data Binding Card - Right Column */}
        <DataBindingCard
          selectedEventType={eventTypeData}
          onUpdate={handleEventTypeUpdate}
        />

        {/* Actions Card - Full Width Below Grid */}
        <div className="actions-card full-width-card">
          <h5 className="actions-title">‚öôÔ∏è Actions</h5>
          <button className="action-button" onClick={() => loadRealEventTypeData(selectedEventType)}>
            Reload EventType File
          </button>
          <button className="action-button" onClick={async () => {
            const { refreshEventTypeRegistry } = await import('../utils/eventTypeDiscovery');
            refreshEventTypeRegistry();
            loadRealEventTypeData(selectedEventType);
          }}>
            Refresh Registry
          </button>
          <button
            className="action-button"
            onClick={handleGenerateFields}
            disabled={!eventTypeData?.qry}
            title={!eventTypeData?.qry ? "EventType missing 'qry' property" : "Generate fields from SQL schema"}
          >
            üîÑ Generate Fields
          </button>
          <button className="action-button">
            Save Changes
          </button>
        </div>
      </div>
    </div>
  );
};

export default ComponentDetailCard;