import { executeQuery } from "./dbUtils.js";
import logger from "./logger.js";

const codeName = "[impactLogger.js]";

/**
 * Log development impacts to plan_impacts table
 * Tracks changes made by Claude/Kiro for coordination
 * Note: batch_id is a virtual column - auto-generated from created_by + created_at
 */
export class ImpactLogger {
  constructor(planId = 1) {
    this.planId = planId;
    this.impacts = [];
  }

  /**
   * Add a file change impact
   */
  addImpact({
    filePath,
    changeType, // 'create', 'modify', 'delete', 'rename'
    description,
    phase = "implementation", // 'idea', 'design', 'implementation', 'testing'
    status = "completed", // 'pending', 'in_progress', 'completed', 'failed'
    affectedApps = [],
    createdBy = "kiro", // 'claude', 'kiro', 'user'
  }) {
    this.impacts.push({
      filePath,
      changeType,
      description,
      phase,
      status,
      affectedApps,
      createdBy,
    });
  }

  /**
   * Log all accumulated impacts to database
   */
  async logImpacts() {
    if (this.impacts.length === 0) {
      logger.debug(`${codeName} No impacts to log`);
      return { success: true, count: 0 };
    }

    try {
      const values = this.impacts
        .map((impact) => {
          const affectedAppsJson = JSON.stringify(impact.affectedApps);

          return `(
          ${this.planId},
          '${impact.filePath.replace(/'/g, "\\'")}',
          '${impact.phase}',
          '${impact.changeType}',
          '${impact.status}',
          '${impact.description.replace(/'/g, "\\'")}',
          '${affectedAppsJson}',
          1,
          NULL,
          NOW(),
          '${impact.createdBy}',
          NOW(),
          '${impact.createdBy}'
        )`;
        })
        .join(",\n");

      const sql = `
        INSERT INTO api_wf.plan_impacts (
          plan_id, file_path, phase, change_type, status, description,
          affected_apps, auto_generated, cross_app_analysis,
          created_at, created_by, updated_at, updated_by
        ) VALUES ${values}
      `;

      const result = await executeQuery(sql, "POST");

      logger.info(
        `${codeName} Logged ${this.impacts.length} impacts`
      );

      // batch_id is virtual - it's auto-generated by the database
      return {
        success: true,
        count: this.impacts.length,
        result,
      };
    } catch (error) {
      logger.error(`${codeName} Failed to log impacts:`, error);
      throw error;
    }
  }

  /**
   * Get recent impacts for coordination
   */
  static async getRecentImpacts(hours = 24) {
    try {
      const sql = `
        SELECT
          id, file_path, change_type, description, phase, status,
          batch_id, affected_apps, created_by, created_at,
          fileName, fileFolder
        FROM api_wf.plan_impacts
        WHERE created_at >= DATE_SUB(NOW(), INTERVAL ${hours} HOUR)
        ORDER BY created_at DESC
        LIMIT 100
      `;

      const result = await executeQuery(sql, "GET");
      return result[0] || [];
    } catch (error) {
      logger.error(`${codeName} Failed to get recent impacts:`, error);
      throw error;
    }
  }

  /**
   * Get impacts by batch for related changes
   */
  static async getBatchImpacts(batchId) {
    try {
      const sql = `
        SELECT
          id, file_path, change_type, description, phase, status,
          affected_apps, created_by, created_at, fileName, fileFolder
        FROM api_wf.plan_impacts
        WHERE batch_id = '${batchId}'
        ORDER BY created_at ASC
      `;

      const result = await executeQuery(sql, "GET");
      return result[0] || [];
    } catch (error) {
      logger.error(`${codeName} Failed to get batch impacts:`, error);
      throw error;
    }
  }
}

/**
 * Convenience function for single impact logging
 */
export const logImpact = async (impactData) => {
  const logger = new ImpactLogger();
  logger.addImpact(impactData);
  return await logger.logImpacts();
};

/**
 * Convenience function for batch impact logging
 */
export const logBatchImpacts = async (impacts, planId = 1) => {
  const logger = new ImpactLogger(planId);
  impacts.forEach((impact) => logger.addImpact(impact));
  return await logger.logImpacts();
};
